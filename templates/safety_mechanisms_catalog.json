{
  "catalog_info": {
    "title": "ISO 26262 Safety Mechanisms Catalog",
    "version": "1.0",
    "description": "Reference catalog of common safety mechanisms per ISO 26262-4:2018, Clause 6.4.5.4",
    "note": "This is a reference catalog. Actual mechanisms must be tailored to specific FSRs and system context."
  },
  
  "mechanism_categories": {
    "diagnostic": {
      "name": "Diagnostic & Detection Mechanisms",
      "description": "Mechanisms that detect faults, malfunctions, or out-of-range conditions",
      "iso_reference": "ISO 26262-5:2018, Clause 8"
    },
    "redundancy": {
      "name": "Redundancy & Fault Tolerance",
      "description": "Mechanisms that provide fault tolerance through redundant channels",
      "iso_reference": "ISO 26262-9:2018, Clause 4"
    },
    "safe_state": {
      "name": "Safe State Management",
      "description": "Mechanisms that transition to and maintain safe states",
      "iso_reference": "ISO 26262-4:2018, Clause 6.4.8"
    },
    "supervision": {
      "name": "Supervision & Monitoring",
      "description": "Mechanisms that monitor execution, timing, and control flow",
      "iso_reference": "ISO 26262-6:2018, Clause 8"
    },
    "communication": {
      "name": "Communication Protection",
      "description": "Mechanisms that ensure data integrity in communication",
      "iso_reference": "ISO 26262-6:2018, Clause 7"
    }
  },
  
  "diagnostic_mechanisms": [
    {
      "id": "SM_DIAG_001",
      "name": "Signal Plausibility Check - Range",
      "description": "Verify sensor signal is within expected physical range (min/max limits). Flag fault if signal exceeds bounds.",
      "applicable_to": ["voltage_sensor", "current_sensor", "temperature_sensor", "pressure_sensor", "position_sensor"],
      "diagnostic_coverage": "90-95%",
      "asil_suitability": ["A", "B", "C", "D"],
      "detection_capability": "Out-of-range sensor faults, sensor disconnection, short circuits",
      "implementation_notes": "Define range limits based on physical constraints. Consider aging and environmental factors.",
      "verification_method": "Fault injection testing with out-of-range signals"
    },
    {
      "id": "SM_DIAG_002",
      "name": "Signal Plausibility Check - Gradient",
      "description": "Monitor rate of change of signal. Flag fault if gradient exceeds physically possible rate of change.",
      "applicable_to": ["all_analog_sensors", "speed_sensor", "acceleration_sensor"],
      "diagnostic_coverage": "85-90%",
      "asil_suitability": ["B", "C", "D"],
      "detection_capability": "Sudden signal jumps, electrical noise, sensor failure transients",
      "implementation_notes": "Calculate maximum physical gradient. Sample rate must be adequate for detection.",
      "verification_method": "Fault injection with step changes"
    },
    {
      "id": "SM_DIAG_003",
      "name": "Signal Plausibility Check - Correlation",
      "description": "Compare related signals for consistency (e.g., voltage vs current, multiple sensors measuring same parameter).",
      "applicable_to": ["redundant_sensors", "related_parameters"],
      "diagnostic_coverage": "85-95%",
      "asil_suitability": ["B", "C", "D"],
      "detection_capability": "Single sensor faults, measurement inconsistencies",
      "implementation_notes": "Define correlation model based on physics. Account for tolerances.",
      "verification_method": "Inject faults in individual channels"
    },
    {
      "id": "SM_DIAG_004",
      "name": "CRC/Checksum Validation",
      "description": "Calculate and verify cyclic redundancy check or checksum for data integrity.",
      "applicable_to": ["communication", "memory", "stored_data"],
      "diagnostic_coverage": "99%",
      "asil_suitability": ["B", "C", "D"],
      "detection_capability": "Bit flips, transmission errors, memory corruption",
      "implementation_notes": "Use appropriate CRC polynomial (CRC16, CRC32) based on data size and ASIL.",
      "verification_method": "Inject bit errors in protected data"
    },
    {
      "id": "SM_DIAG_005",
      "name": "Memory ECC (Error Correction Code)",
      "description": "Detect and correct single-bit errors, detect multi-bit errors in RAM/ROM.",
      "applicable_to": ["RAM", "ROM", "EEPROM"],
      "diagnostic_coverage": "Single-bit: 100%, Multi-bit: >99%",
      "asil_suitability": ["C", "D"],
      "detection_capability": "Memory bit flips from radiation, aging, disturbance",
      "implementation_notes": "Hardware ECC preferred. Use SECDED (Single Error Correction, Double Error Detection).",
      "verification_method": "Fault injection in memory cells"
    },
    {
      "id": "SM_DIAG_006",
      "name": "Built-In Self-Test (BIST)",
      "description": "Periodic self-test of hardware components (CPU, memory, peripherals) during initialization or runtime.",
      "applicable_to": ["microcontroller", "ASIC", "FPGA"],
      "diagnostic_coverage": "60-90% depending on test coverage",
      "asil_suitability": ["A", "B", "C", "D"],
      "detection_capability": "Permanent faults in digital logic, stuck-at faults",
      "implementation_notes": "Run at startup and periodically. Test duration vs availability trade-off.",
      "verification_method": "Inject permanent faults"
    },
    {
      "id": "SM_DIAG_007",
      "name": "Analog-to-Digital Converter Test",
      "description": "Test ADC accuracy using reference voltage or self-test channels.",
      "applicable_to": ["ADC", "sensor_interface"],
      "diagnostic_coverage": "80-90%",
      "asil_suitability": ["B", "C", "D"],
      "detection_capability": "ADC offset errors, gain errors, non-linearity",
      "implementation_notes": "Use internal reference or test channel. Periodic calibration.",
      "verification_method": "Inject ADC errors"
    },
    {
      "id": "SM_DIAG_008",
      "name": "Voltage Monitoring",
      "description": "Monitor power supply voltage for under-voltage and over-voltage conditions.",
      "applicable_to": ["power_supply", "battery", "voltage_regulator"],
      "diagnostic_coverage": "95-99%",
      "asil_suitability": ["A", "B", "C", "D"],
      "detection_capability": "Power supply failures, battery degradation",
      "implementation_notes": "Hardware comparator or software monitoring. Define thresholds with margin.",
      "verification_method": "Vary supply voltage"
    }
  ],
  
  "redundancy_mechanisms": [
    {
      "id": "SM_REDUND_001",
      "name": "Dual Channel Redundancy (1oo2D)",
      "description": "Two independent channels monitor same parameter. Fault declared if channels disagree beyond threshold.",
      "applicable_to": ["sensors", "actuators", "processing"],
      "diagnostic_coverage": "95-99%",
      "asil_suitability": ["B", "C", "D"],
      "independence_level": "Channels must have independent HW, power, and signal paths",
      "implementation_notes": "Define disagreement threshold considering tolerances. Handle single channel failures.",
      "verification_method": "Inject fault in one channel"
    },
    {
      "id": "SM_REDUND_002",
      "name": "Triple Modular Redundancy (2oo3 Voting)",
      "description": "Three independent channels with majority voting. System continues with single fault.",
      "applicable_to": ["critical_sensors", "critical_processing", "safety_critical_outputs"],
      "diagnostic_coverage": "99%+",
      "asil_suitability": ["C", "D"],
      "independence_level": "Full independence required - separate HW, SW, power",
      "implementation_notes": "Higher cost. Handles single fault gracefully. Detect and report faulty channel.",
      "verification_method": "Inject faults in individual channels"
    },
    {
      "id": "SM_REDUND_003",
      "name": "Diverse Redundancy",
      "description": "Use different sensor technologies or measurement principles for same parameter.",
      "applicable_to": ["critical_measurements"],
      "diagnostic_coverage": "90-95%",
      "asil_suitability": ["C", "D"],
      "independence_level": "Different technologies reduce common cause failures",
      "implementation_notes": "More complex to calibrate. Protects against systematic faults in one technology.",
      "verification_method": "Inject technology-specific faults"
    },
    {
      "id": "SM_REDUND_004",
      "name": "Lockstep CPUs",
      "description": "Two CPUs execute identical code in parallel. Compare results each cycle.",
      "applicable_to": ["microcontroller", "ECU_processing"],
      "diagnostic_coverage": "99%+",
      "asil_suitability": ["C", "D"],
      "independence_level": "Physical separation on same die or separate dies",
      "implementation_notes": "Hardware solution. Immediate fault detection. Single clock cycle latency.",
      "verification_method": "Inject transient faults in one core"
    },
    {
      "id": "SM_REDUND_005",
      "name": "Backup Sensor/Actuator",
      "description": "Secondary sensor or actuator ready to take over if primary fails.",
      "applicable_to": ["sensors", "actuators"],
      "diagnostic_coverage": "90-95%",
      "asil_suitability": ["B", "C"],
      "independence_level": "Separate mounting, power, wiring",
      "implementation_notes": "Monitor both. Switch on primary failure. Verify backup operational.",
      "verification_method": "Disconnect primary"
    }
  ],
  
  "safe_state_mechanisms": [
    {
      "id": "SM_SAFE_001",
      "name": "Controlled Shutdown Sequence",
      "description": "Orderly shutdown of functions when fault detected. Return to defined safe state.",
      "applicable_to": ["all_systems"],
      "diagnostic_coverage": "N/A (reaction mechanism)",
      "asil_suitability": ["A", "B", "C", "D"],
      "reaction_time": "Defined by FTTI",
      "implementation_notes": "Define shutdown steps. Ensure state reachable within FTTI. Test all scenarios.",
      "verification_method": "Trigger faults and verify shutdown"
    },
    {
      "id": "SM_SAFE_002",
      "name": "Fail-Safe Default Position",
      "description": "Actuator moves to mechanically safe position on power loss or fault (e.g., spring return).",
      "applicable_to": ["valves", "clutches", "brakes"],
      "diagnostic_coverage": "N/A (reaction mechanism)",
      "asil_suitability": ["A", "B", "C", "D"],
      "reaction_time": "Immediate (mechanical)",
      "implementation_notes": "Design mechanical default. Verify safe position is truly safe in all scenarios.",
      "verification_method": "Remove power/control signal"
    },
    {
      "id": "SM_SAFE_003",
      "name": "Degraded Mode Operation",
      "description": "System continues with reduced functionality when fault detected. Full safety maintained.",
      "applicable_to": ["multi_function_systems"],
      "diagnostic_coverage": "N/A (reaction mechanism)",
      "asil_suitability": ["A", "B", "C"],
      "reaction_time": "Defined by requirements",
      "implementation_notes": "Define degraded modes. Ensure safety in each mode. Inform driver of degradation.",
      "verification_method": "Trigger faults and verify degraded operation"
    },
    {
      "id": "SM_SAFE_004",
      "name": "Emergency Operation Timeout",
      "description": "Allow limited time emergency operation after fault, then force safe state.",
      "applicable_to": ["propulsion", "steering", "braking"],
      "diagnostic_coverage": "N/A (reaction mechanism)",
      "asil_suitability": ["B", "C"],
      "reaction_time": "Emergency period defined, then FTTI to safe state",
      "implementation_notes": "Define emergency operation constraints. Ensure safe state after timeout.",
      "verification_method": "Let emergency timer expire"
    },
    {
      "id": "SM_SAFE_005",
      "name": "Output Clamping/Limiting",
      "description": "Limit actuator output to safe range when fault suspected. Prevent dangerous values.",
      "applicable_to": ["actuators", "outputs"],
      "diagnostic_coverage": "N/A (reaction mechanism)",
      "asil_suitability": ["A", "B", "C"],
      "reaction_time": "Immediate",
      "implementation_notes": "Define safe output limits. Implement in hardware if possible.",
      "verification_method": "Command out-of-range outputs"
    }
  ],
  
  "supervision_mechanisms": [
    {
      "id": "SM_SUPERV_001",
      "name": "Watchdog Timer",
      "description": "Timer must be periodically reset by software. If not reset, hardware forces safe state/reset.",
      "applicable_to": ["software", "microcontroller"],
      "diagnostic_coverage": "90-95%",
      "asil_suitability": ["A", "B", "C", "D"],
      "detection_capability": "Software hangs, infinite loops, timing failures",
      "implementation_notes": "Window watchdog preferred (too early and too late detection). Independent timer required.",
      "verification_method": "Prevent watchdog refresh"
    },
    {
      "id": "SM_SUPERV_002",
      "name": "Execution Time Monitoring",
      "description": "Monitor execution time of critical functions. Flag fault if execution exceeds deadline.",
      "applicable_to": ["real_time_tasks", "cyclic_functions"],
      "diagnostic_coverage": "85-90%",
      "asil_suitability": ["B", "C", "D"],
      "detection_capability": "Timing violations, overload, stuck code",
      "implementation_notes": "Define worst-case execution time + margin. Use hardware timer.",
      "verification_method": "Delay task execution"
    },
    {
      "id": "SM_SUPERV_003",
      "name": "Alive/Heartbeat Monitoring",
      "description": "Monitor that module/task is executing periodically. Flag fault if heartbeat stops.",
      "applicable_to": ["distributed_systems", "communication_partners"],
      "diagnostic_coverage": "90-95%",
      "asil_suitability": ["A", "B", "C"],
      "detection_capability": "Module crashes, communication loss, partner failure",
      "implementation_notes": "Define heartbeat period. Multiple missed beats before fault.",
      "verification_method": "Stop heartbeat transmission"
    },
    {
      "id": "SM_SUPERV_004",
      "name": "Control Flow Monitoring",
      "description": "Verify software follows expected execution path. Detect jumps, skips, corruption.",
      "applicable_to": ["safety_critical_software"],
      "diagnostic_coverage": "70-85%",
      "asil_suitability": ["C", "D"],
      "detection_capability": "Code corruption, jumps to wrong addresses, control flow errors",
      "implementation_notes": "Use checkpoints or signatures. Can be SW or HW based.",
      "verification_method": "Inject control flow errors"
    },
    {
      "id": "SM_SUPERV_005",
      "name": "Stack Overflow Detection",
      "description": "Monitor stack usage. Detect if stack grows beyond allocated space.",
      "applicable_to": ["software_tasks"],
      "diagnostic_coverage": "95-99%",
      "asil_suitability": ["B", "C", "D"],
      "detection_capability": "Stack overflow from recursion, large local variables",
      "implementation_notes": "Use stack canary or guard pages. Check periodically.",
      "verification_method": "Allocate large stack variables"
    },
    {
      "id": "SM_SUPERV_006",
      "name": "CPU Load Monitoring",
      "description": "Monitor CPU utilization. Flag fault if load exceeds threshold (overload condition).",
      "applicable_to": ["real_time_systems"],
      "diagnostic_coverage": "80-90%",
      "asil_suitability": ["B", "C"],
      "detection_capability": "System overload, too many tasks, runaway processes",
      "implementation_notes": "Define maximum acceptable load with margin. Measure idle time.",
      "verification_method": "Add CPU-intensive tasks"
    }
  ],
  
  "communication_mechanisms": [
    {
      "id": "SM_COMM_001",
      "name": "Message CRC",
      "description": "Append CRC to each message. Receiver verifies CRC before using data.",
      "applicable_to": ["CAN", "LIN", "Ethernet", "internal_messaging"],
      "diagnostic_coverage": "99%+",
      "asil_suitability": ["B", "C", "D"],
      "detection_capability": "Bit errors in transmission, EMI-induced corruption",
      "implementation_notes": "Use CRC16 or CRC32 based on message size. Hardware CRC preferred.",
      "verification_method": "Corrupt message bits"
    },
    {
      "id": "SM_COMM_002",
      "name": "Sequence Counter",
      "description": "Increment counter in each message. Detect lost, repeated, or out-of-order messages.",
      "applicable_to": ["cyclic_messages", "CAN", "Ethernet"],
      "diagnostic_coverage": "90-95%",
      "asil_suitability": ["B", "C", "D"],
      "detection_capability": "Message loss, repetition, reordering",
      "implementation_notes": "Rolling counter (e.g., 0-15). Define expected sequence.",
      "verification_method": "Drop, repeat, or reorder messages"
    },
    {
      "id": "SM_COMM_003",
      "name": "Message Timeout",
      "description": "Monitor reception of periodic messages. Flag fault if message not received within timeout.",
      "applicable_to": ["cyclic_messages", "all_protocols"],
      "diagnostic_coverage": "95-99%",
      "asil_suitability": ["A", "B", "C", "D"],
      "detection_capability": "Transmitter failure, bus failure, cable disconnection",
      "implementation_notes": "Timeout = message period Ã— 2-3. Trigger safe state on timeout.",
      "verification_method": "Stop transmitting messages"
    },
    {
      "id": "SM_COMM_004",
      "name": "Source Address Authentication",
      "description": "Verify message came from expected source. Prevent spoofing.",
      "applicable_to": ["security_critical_messages", "CAN", "Ethernet"],
      "diagnostic_coverage": "90-95%",
      "asil_suitability": ["B", "C", "D"],
      "detection_capability": "Message spoofing, incorrect sender",
      "implementation_notes": "Check sender ID. Use authentication code if needed.",
      "verification_method": "Send message from wrong source"
    },
    {
      "id": "SM_COMM_005",
      "name": "Message Timestamp",
      "description": "Timestamp each message. Receiver checks for freshness. Detect replay attacks.",
      "applicable_to": ["security_critical", "Ethernet"],
      "diagnostic_coverage": "85-90%",
      "asil_suitability": ["C", "D"],
      "detection_capability": "Replay attacks, old messages",
      "implementation_notes": "Synchronized time base required. Define maximum age.",
      "verification_method": "Send old messages"
    },
    {
      "id": "SM_COMM_006",
      "name": "End-to-End Protection (E2E)",
      "description": "Comprehensive protection combining CRC, counter, timeout, and other checks.",
      "applicable_to": ["AUTOSAR", "safety_critical_paths"],
      "diagnostic_coverage": "99%+",
      "asil_suitability": ["C", "D"],
      "detection_capability": "Comprehensive: corruption, loss, delay, repetition",
      "implementation_notes": "Use AUTOSAR E2E profiles. Covers entire communication path.",
      "verification_method": "Comprehensive fault injection campaign"
    }
  ],
  
  "asil_recommendations": {
    "ASIL_A": {
      "minimum_mechanisms": 1,
      "recommended_types": ["diagnostic", "supervision"],
      "notes": "Simple mechanisms sufficient. Single layer of protection."
    },
    "ASIL_B": {
      "minimum_mechanisms": 2,
      "recommended_types": ["diagnostic", "safe_state", "supervision"],
      "notes": "Multiple independent mechanisms. Detect + react."
    },
    "ASIL_C": {
      "minimum_mechanisms": 3,
      "recommended_types": ["diagnostic", "redundancy", "safe_state", "supervision"],
      "notes": "Comprehensive protection. Consider redundancy for critical paths."
    },
    "ASIL_D": {
      "minimum_mechanisms": 3,
      "recommended_types": ["diagnostic", "redundancy", "safe_state", "supervision", "communication"],
      "notes": "Highest protection. Redundancy often required. Comprehensive testing."
    }
  },
  
  "usage_guidelines": {
    "selection": "Select mechanisms based on FSR type, ASIL level, failure modes, and system architecture.",
    "combination": "Combine mechanisms for defense in depth. Ensure mechanisms are independent.",
    "verification": "Each mechanism must be verifiable. Define test methods for fault injection.",
    "documentation": "Document mechanism rationale, coverage, and verification results."
  }
}